# Charlie Reporting - Copilot Context

## Project Overview

**Charlie Reporting** is a portfolio-grade microservices architecture project that transforms a Windows desktop email automation system into a modern, enterprise-ready distributed platform. The project demonstrates end-to-end system design from legacy desktop automation to cloud-native Kubernetes deployment.

### Project Evolution
1. **Phase 1 (Current)**: Windows desktop application with email fetching and Excel report generation
2. **Phase 2 (In Progress)**: Microservices architecture with standardized patterns
3. **Phase 3 (Planned)**: Kubernetes deployment with full observability stack

## Architecture Overview

### Core Microservices (5 Services)
The system is built around 5 core microservices, each running on dedicated ports:

1. **Outlook Relay Service** (Port 8080)
   - Purpose: Windows/Exchange email proxy and attachment processing
   - Technology: Python, pywin32 COM or Microsoft Graph API
   - Responsibilities: Email fetching, CSV extraction, outbound email sending

2. **Database Service** (Port 8081)
   - Purpose: Centralized data storage and retrieval
   - Technology: Python, FastAPI, SQLAlchemy, PostgreSQL/SQLite
   - Responsibilities: CSV data storage, report metadata, query APIs

3. **Scheduler Service** (Port 8082)
   - Purpose: Automated task scheduling and orchestration
   - Technology: Python, FastAPI, APScheduler
   - Responsibilities: Time-based triggers, workflow coordination, user interface

4. **Report Generator Service** (Port 8083)
   - Purpose: Excel report creation and formatting
   - Technology: Python, FastAPI, openpyxl/xlsxwriter
   - Responsibilities: Template-based Excel generation, data aggregation

5. **Email Service** (Port 8084)
   - Purpose: Outbound email delivery and templates
   - Technology: Python, FastAPI, SMTP/Graph API
   - Responsibilities: Email composition, template processing, delivery tracking

### Communication Pattern
- **Protocol**: HTTP REST APIs (future migration to Kafka for async events)
- **Service Discovery**: In-memory registry (production: Consul/etcd)
- **Load Balancing**: Round-robin with health checks
- **Authentication**: JWT tokens for service-to-service communication

## Standardized Service Architecture

### Directory Structure (SoC Pattern)
Every service follows identical structure for consistency:

```
service-name/
â”œâ”€â”€ config/                    # Configuration management (TOML + env vars)
â”œâ”€â”€ run/                       # Entry points (service.py, cli.py, health_check.py)
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ business/              # Domain logic (models, services, handlers)
â”‚   â”œâ”€â”€ interfaces/            # External APIs (REST, CLI, events)
â”‚   â”œâ”€â”€ infrastructure/        # Cross-cutting (logging, metrics, health)
â”‚   â””â”€â”€ utils/                 # Service-specific utilities
â”œâ”€â”€ tests/                     # Comprehensive test suite
â”œâ”€â”€ Dockerfile                 # Container definition
â”œâ”€â”€ requirements.txt           # Python dependencies
â””â”€â”€ service.bat               # Windows service runner
```

### Shared Foundation Components

Located in `/shared/` directory, providing enterprise-grade patterns:

#### Core Infrastructure
- **`base_service.py`**: Abstract base class with async lifecycle, signal handling, graceful shutdown
- **`config.py`**: Environment-aware configuration with Pydantic validation and TOML support
- **`metrics.py`**: Prometheus-compatible metrics (HTTP requests, business operations, health status)
- **`logging.py`**: Structured JSON logging with request correlation and service context
- **`health.py`**: Comprehensive health monitoring with pluggable checkers (DB, HTTP, memory, disk)

#### Service Communication
- **`discovery.py`**: Service registry with heartbeat monitoring and client-side load balancing
- **`http_utils.py`**: FastAPI middleware, error handlers, security headers, standard endpoints

#### Utilities & Resilience
- **`utils.py`**: Common helpers (ID generation, retry logic, circuit breakers, validation)
- **Requirements**: Complete dependency list for enterprise-grade Python stack

## Technology Stack

### Core Framework
- **API Framework**: FastAPI with async/await patterns
- **Configuration**: Pydantic Settings with TOML and environment variable support
- **Database**: SQLAlchemy with async drivers (PostgreSQL primary, SQLite dev)
- **Task Scheduling**: APScheduler for time-based automation

### Observability & Monitoring
- **Metrics**: Prometheus-compatible collection with custom business metrics
- **Logging**: Structured JSON logs with correlation IDs and service context
- **Health Checks**: Multi-level health monitoring (service, component, dependency)
- **Tracing**: OpenTelemetry-ready for distributed tracing

### Deployment & Operations
- **Containerization**: Docker with multi-stage builds
- **Orchestration**: Docker Compose â†’ Kubernetes migration path
- **CI/CD**: GitHub Actions with automated testing and deployment
- **Configuration**: Environment-specific TOML files with secrets management

## Business Logic Flow

### Email Processing Pipeline
1. **Scheduler Service** triggers email fetch based on time or manual request
2. **Outlook Relay Service** connects to Exchange/Outlook, extracts emails and CSV attachments
3. **Database Service** stores CSV data with metadata (timestamps, source info, validation status)
4. **Report Generator Service** queries aggregated data and creates Excel reports
5. **Email Service** sends completed reports to distribution lists

### Data Flow Patterns
- **Inbound**: Email â†’ CSV extraction â†’ Data validation â†’ Database storage
- **Processing**: Scheduled aggregation â†’ Template-based Excel generation
- **Outbound**: Report delivery via email with tracking and retry logic

## Enterprise Patterns Demonstrated

### Separation of Concerns (SoC)
- **Business Layer**: Pure domain logic, no infrastructure dependencies
- **Interface Layer**: HTTP APIs, CLI commands, event handlers
- **Infrastructure Layer**: Logging, metrics, health checks, configuration

### Resilience & Reliability
- **Circuit Breakers**: External service failure protection
- **Retry Logic**: Exponential backoff for transient failures
- **Health Monitoring**: Continuous component and dependency health checks
- **Graceful Shutdown**: Proper resource cleanup and signal handling

### Observability
- **Structured Logging**: JSON logs with correlation IDs across service boundaries
- **Metrics Collection**: Business and technical metrics for monitoring and alerting
- **Health Endpoints**: Kubernetes-compatible readiness and liveness probes
- **Request Tracing**: Full request lifecycle tracking for debugging

## Current Implementation Status

### âœ… Completed
- **Shared Foundation**: All 8 shared components implemented with enterprise patterns
- **Architecture Design**: Complete microservices design with service boundaries
- **Implementation Plan**: 8-week roadmap with clear milestones
- **Documentation**: Comprehensive architecture and patterns documentation

### ðŸš§ In Progress
- **Service Implementation**: Ready to implement individual services using shared foundation
- **Dependency Resolution**: Installing required packages for development environment

### ðŸ“‹ Next Steps
1. **Outlook Relay Service**: First service implementation using existing email fetching code
2. **Database Service**: Data storage and query APIs
3. **Integration Testing**: Service-to-service communication validation
4. **Docker Deployment**: Containerization and Docker Compose setup

## Development Context

### Current Codebase
- **Original Windows App**: Functional email fetching and Excel generation in `/src/`
- **Microservices Foundation**: Enterprise-grade shared components in `/shared/`
- **Configuration**: Service-specific configs in `/config/` with TOML format
- **Testing**: Integration test framework in `/tests/` with mock services

### Key Files & Patterns
- **Entry Points**: Each service has standardized `run/service.py` for consistent startup
- **Configuration**: Environment-aware loading with `config/settings.py` and TOML files
- **Health Monitoring**: Pluggable health checkers for databases, HTTP services, system resources
- **Service Discovery**: Automatic registration and heartbeat with client-side load balancing

### Code Quality Standards
- **Type Hints**: Full type annotation with mypy validation
- **Error Handling**: Structured exceptions with proper logging and metrics
- **Testing**: Unit and integration tests with pytest and async test patterns
- **Documentation**: Comprehensive docstrings and usage examples

## Portfolio Value Proposition

This project demonstrates:
1. **System Design**: End-to-end microservices architecture with proper service boundaries
2. **Enterprise Patterns**: SoC, observability, resilience, and configuration management
3. **Technology Breadth**: Modern Python, async programming, containerization, monitoring
4. **Real-world Problem**: Practical business automation with measurable impact
5. **Evolution Strategy**: Clear migration path from desktop to cloud-native deployment

The codebase showcases production-ready patterns while solving an actual business problem, making it an ideal portfolio piece for demonstrating enterprise software development skills.

## Development Guidelines

### Adding New Services
1. Follow standardized directory structure in `/shared/README.md`
2. Inherit from `BaseService` for consistent lifecycle management
3. Use `ServiceMetrics` and `ServiceLogger` for observability
4. Implement health checks for all external dependencies
5. Add comprehensive tests with integration scenarios

### Configuration Management
- Use Pydantic models for type-safe configuration
- Environment-specific TOML files for different deployment stages
- Secrets via environment variables or external secret management
- Validation at startup with clear error messages

### Observability Best Practices
- Structured JSON logging with correlation IDs
- Business metrics alongside technical metrics
- Health checks for all dependencies
- Request/response logging with duration tracking

This context provides the foundation for consistent development across all microservices while maintaining enterprise-grade quality and patterns.
