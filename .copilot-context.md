# Charlie Reporting - Copilot Context

## Project Overview

**Charlie Reporting** is a portfolio-grade microservices architecture project that transforms a Windows desktop email automation system into a modern, enterprise-ready distributed platform. The project demonstrates end-to-end system design from legacy desktop automation to cloud-native Kubernetes deployment.

### Project Evolution

1. **Phase 1 (Current)**: Windows desktop application with email fetching and Excel report generation
2. **Phase 2 (In Progress)**: Microservices architecture with standardized patterns
3. **Phase 3 (Planned)**: Kubernetes deployment with full observability stack

## Architecture Overview

### Core Microservices (5 Services)

The system is built around 5 core microservices, each running on dedicated ports:

1. **Outlook Relay Service** (Port 8080)
   - Purpose: Windows/Exchange email proxy and attachment processing
   - Technology: Python, pywin32 COM or Microsoft Graph API
   - Responsibilities: Email fetching, CSV extraction, outbound email sending

2. **Database Service** (Port 8081)
   - Purpose: Centralized data storage and retrieval
   - Technology: Python, FastAPI, SQLAlchemy, PostgreSQL/SQLite
   - Responsibilities: CSV data storage, report metadata, query APIs

3. **Scheduler Service** (Port 8082)
   - Purpose: Automated task scheduling and orchestration
   - Technology: Python, FastAPI, APScheduler
   - Responsibilities: Time-based triggers, workflow coordination, user interface

4. **Report Generator Service** (Port 8083)
   - Purpose: Excel report creation and formatting
   - Technology: Python, FastAPI, openpyxl/xlsxwriter
   - Responsibilities: Template-based Excel generation, data aggregation

5. **Email Service** (Port 8084)
   - Purpose: Outbound email delivery and templates
   - Technology: Python, FastAPI, SMTP/Graph API
   - Responsibilities: Email composition, template processing, delivery tracking

### Communication Pattern

- **Protocol**: HTTP REST APIs (future migration to Kafka for async events)
- **Service Discovery**: In-memory registry (production: Consul/etcd)
- **Load Balancing**: Round-robin with health checks
- **Authentication**: JWT tokens for service-to-service communication

## Standardized Service Architecture

### Directory Structure (SoC Pattern)

Every service follows identical structure for consistency:

service-name/
├── config/                    # Configuration management (TOML + env vars)
├── run/                       # Entry points (service.py, cli.py, health_check.py)
├── src/
│   ├── business/              # Domain logic (models, services, handlers)
│   ├── interfaces/            # External APIs (REST, CLI, events)
│   ├── infrastructure/        # Cross-cutting (logging, metrics, health)
│   └── utils/                 # Service-specific utilities
├── tests/                     # Comprehensive test suite
├── Dockerfile                 # Container definition
├── requirements.txt           # Python dependencies
└── service.bat               # Windows service runner

### Shared Foundation Components

Located in `/shared/` directory, providing enterprise-grade patterns:

#### Core Infrastructure

- **`base_service.py`**: Abstract base class with async lifecycle, signal handling, graceful shutdown
- **`config.py`**: Environment-aware configuration with Pydantic validation and TOML support
- **`metrics.py`**: Prometheus-compatible metrics (HTTP requests, business operations, health status)
- **`logging.py`**: Structured JSON logging with request correlation and service context
- **`health.py`**: Comprehensive health monitoring with pluggable checkers (DB, HTTP, memory, disk)

#### Service Communication

- **`discovery.py`**: Service registry with heartbeat monitoring and client-side load balancing
- **`http_utils.py`**: FastAPI middleware, error handlers, security headers, standard endpoints

#### Utilities & Resilience

- **`utils.py`**: Common helpers (ID generation, retry logic, circuit breakers, validation)
- **Requirements**: Complete dependency list for enterprise-grade Python stack

## Technology Stack

### Core Framework

- **API Framework**: FastAPI with async/await patterns
- **Configuration**: Pydantic Settings with TOML and environment variable support
- **Database**: SQLAlchemy with async drivers (PostgreSQL primary, SQLite dev)
- **Task Scheduling**: APScheduler for time-based automation

### Observability & Monitoring

- **Metrics**: Prometheus-compatible collection with custom business metrics
- **Logging**: Structured JSON logs with correlation IDs and service context
- **Health Checks**: Multi-level health monitoring (service, component, dependency)
- **Tracing**: OpenTelemetry-ready for distributed tracing

### Deployment & Operations

- **Containerization**: Docker with multi-stage builds
- **Orchestration**: Docker Compose → Kubernetes migration path
- **CI/CD**: GitHub Actions with automated testing and deployment
- **Configuration**: Environment-specific TOML files with secrets management

## Business Logic Flow

### Email Processing Pipeline

1. **Scheduler Service** triggers email fetch based on time or manual request
2. **Outlook Relay Service** connects to Exchange/Outlook, extracts emails and CSV attachments
3. **Database Service** stores CSV data with metadata (timestamps, source info, validation status)
4. **Report Generator Service** queries aggregated data and creates Excel reports
5. **Email Service** sends completed reports to distribution lists

### Data Flow Patterns

- **Inbound**: Email → CSV extraction → Data validation → Database storage
- **Processing**: Scheduled aggregation → Template-based Excel generation
- **Outbound**: Report delivery via email with tracking and retry logic

## Enterprise Patterns Demonstrated

### Separation of Concerns (SoC)

- **Business Layer**: Pure domain logic, no infrastructure dependencies
- **Interface Layer**: HTTP APIs, CLI commands, event handlers
- **Infrastructure Layer**: Logging, metrics, health checks, configuration

### Resilience & Reliability

- **Circuit Breakers**: External service failure protection
- **Retry Logic**: Exponential backoff for transient failures
- **Health Monitoring**: Continuous component and dependency health checks
- **Graceful Shutdown**: Proper resource cleanup and signal handling

### Observability

- **Structured Logging**: JSON logs with correlation IDs across service boundaries
- **Metrics Collection**: Business and technical metrics for monitoring and alerting
- **Health Endpoints**: Kubernetes-compatible readiness and liveness probes
- **Request Tracing**: Full request lifecycle tracking for debugging

## Current Implementation Status

### ✅ Completed

- **Shared Foundation**: All 8 shared components implemented with enterprise patterns
- **Architecture Design**: Complete microservices design with service boundaries
- **Implementation Plan**: 8-week roadmap with clear milestones
- **Documentation**: Comprehensive architecture and patterns documentation

### 🚧 In Progress

- **Service Implementation**: Ready to implement individual services using shared foundation
- **Dependency Resolution**: Installing required packages for development environment

### 📋 Next Steps

1. **Outlook Relay Service**: First service implementation using existing email fetching code
2. **Database Service**: Data storage and query APIs
3. **Integration Testing**: Service-to-service communication validation
4. **Docker Deployment**: Containerization and Docker Compose setup

## Development Context

### Current Codebase

- **Original Windows App**: Functional email fetching and Excel generation in `/src/`
- **Microservices Foundation**: Enterprise-grade shared components in `/shared/`
- **Configuration**: Service-specific configs in `/config/` with TOML format
- **Testing**: Integration test framework in `/tests/` with mock services

### Key Files & Patterns

- **Entry Points**: Each service has standardized `run/service.py` for consistent startup
- **Configuration**: Environment-aware loading with `config/settings.py` and TOML files
- **Health Monitoring**: Pluggable health checkers for databases, HTTP services, system resources
- **Service Discovery**: Automatic registration and heartbeat with client-side load balancing

### Code Quality Standards

- **Type Hints**: Full type annotation with mypy validation
- **Error Handling**: Structured exceptions with proper logging and metrics
- **Testing**: Unit and integration tests with pytest and async test patterns
- **Documentation**: Comprehensive docstrings and usage examples

## Portfolio Value Proposition

This project demonstrates:

1. **System Design**: End-to-end microservices architecture with proper service boundaries
2. **Enterprise Patterns**: SoC, observability, resilience, and configuration management
3. **Technology Breadth**: Modern Python, async programming, containerization, monitoring
4. **Real-world Problem**: Practical business automation with measurable impact
5. **Evolution Strategy**: Clear migration path from desktop to cloud-native deployment

The codebase showcases production-ready patterns while solving an actual business problem, making it an ideal portfolio piece for demonstrating enterprise software development skills.

## Development Guidelines

### Adding New Services

1. Follow standardized directory structure in `/shared/README.md`
2. Inherit from `BaseService` for consistent lifecycle management
3. Use `ServiceMetrics` and `ServiceLogger` for observability
4. Implement health checks for all external dependencies
5. Add comprehensive tests with integration scenarios

### Configuration Management

- Use Pydantic models for type-safe configuration
- Environment-specific TOML files for different deployment stages
- Secrets via environment variables or external secret management
- Validation at startup with clear error messages

### Observability Best Practices

- Structured JSON logging with correlation IDs
- Business metrics alongside technical metrics
- Health checks for all dependencies
- Request/response logging with duration tracking

### **🚨 MANDATORY: Lessons Learned Maintenance**

**CRITICAL INSTRUCTION**: Every time you perform troubleshooting, debugging, or encounter any technical issue, you MUST:

1. **Immediately** add the issue to the Bug Log & Solutions section with:
   - Brief problem description (1-2 lines)
   - Root cause (1 line)
   - Quick solution (1-2 lines)
   - Prevention tip (1 line)

2. **Update** the Lessons Learned & Error Prevention section with:
   - Concise what went wrong and why
   - Brief detection method
   - Key pattern/practice to avoid
   - Single preventive check

3. **Keep entries minimal** - focus on essential information only to preserve context space

**Purpose**: Build institutional knowledge efficiently without consuming excessive context.

### 🚨 **MANDATORY: Plan and Architect Before Implement**

**CRITICAL RULE**: All architectural changes MUST be planned and documented first:

1. **Design before code** - Document architectural decisions in `/docs/architecture/`
2. **Justify decisions** - Include reasoning, alternatives considered, and trade-offs
3. **Review dependencies** - Analyze impact on existing services and tests
4. **Plan implementation** - Break down into phases with clear deliverables
5. **Update documentation** - Keep architecture docs current with implementation

### 🚨 **MANDATORY: Test-Driven Development (TDD)**

**CRITICAL RULE**: Every feature MUST have tests BEFORE implementation:

1. **Write tests first** - Use pytest for all validation, never manual terminal testing
2. **Three-layer testing** - Unit (business), integration (interface), e2e (full workflow)  
3. **Coverage requirement** - Minimum 80% code coverage for all business logic
4. **Automated validation** - All tests must run in CI/CD pipeline
5. **Test documentation** - Every test explains what behavior it validates

**TDD Workflow**:

- Red: Write failing test for new feature
- Green: Write minimal code to pass test  
- Refactor: Improve code while keeping tests green
- Document: Update test descriptions and coverage

**Prohibited Practices**:

- ❌ Manual terminal testing for validation
- ❌ Implementing features without tests
- ❌ Committing code with failing tests
- ❌ Skipping test coverage checks
- ❌ Starting implementation without architectural planning

This context provides the foundation for consistent development across all microservices while maintaining enterprise-grade quality and patterns.

## Quick Reference Maps

### Service Implementation Checklist

When implementing any service, always include:

1. **Business Layer**: Domain models, services, handlers (pure logic)
2. **Interface Layer**: FastAPI routes, CLI commands, event handlers  
3. **Infrastructure Layer**: Health checks, metrics, logging, configuration
4. **Tests**: Unit tests for business logic, integration tests for APIs

### Test Structure Per Layer

- `tests/unit/business/` → Pure business logic tests (no I/O)
- `tests/integration/interface/` → API endpoint tests with TestClient
- `tests/integration/infrastructure/` → Database, metrics, logging tests
- `tests/e2e/` → Complete workflow tests with realistic data
- `tests/fixtures/` → Test data factories and sample files

### Standard File Mappings

- `src/business/models/` → Domain entities and value objects
- `src/business/services/` → Core business logic services
- `src/interfaces/rest/routes.py` → FastAPI endpoints
- `src/infrastructure/health.py` → Health check implementations
- `tests/unit/` → Business logic tests
- `tests/integration/` → API and service integration tests

### Architecture Decision Records (ADRs)

- **SoC Pattern**: Business/Interface/Infrastructure separation enforced
- **FastAPI**: Chosen for async performance and automatic OpenAPI docs
- **Pydantic**: Type-safe configuration and request/response models
- **SQLAlchemy**: Database ORM with async support
- **Prometheus**: Metrics collection standard across all services

### Common Implementation Patterns

```python
# Business Service Pattern
class BusinessService:
    def __init__(self, dependencies: Dependencies):
        self._deps = dependencies
    
    def business_operation(self, domain_input: DomainModel) -> DomainResult:
        # Pure business logic only

# FastAPI Route Pattern  
@router.post("/endpoint")
async def endpoint(
    request: RequestModel,
    service: BusinessService = Depends(get_business_service)
) -> ResponseModel:
    result = service.business_operation(request.to_domain())
    return ResponseModel.from_domain(result)
```

## Bug Log & Solutions

*Keep detailed records of bugs encountered and their solutions to prevent recurrence*

### BUG-001: Pydantic v2 Validation Issues

**Date**: 2025-07-29  
**Service**: report-generator  
**Issue**: `regex` parameter deprecated in Pydantic v2, causing validation errors in request schemas  
**Symptoms**: `RegexError` when using `Field(..., regex=r"pattern")` in schema definitions  
**Root Cause**: Pydantic v2 changed `regex` parameter to `pattern`  
**Solution**: Replace `regex=` with `pattern=` in all Field definitions  
**Files Changed**: `src/interface/schemas.py`  
**Prevention**: Always check Pydantic version compatibility when upgrading dependencies  

**Code Fix**:

```python
# WRONG (Pydantic v2):
date_filter: str = Field(..., regex=r"^\d{4}-\d{2}-\d{2}$")

# CORRECT (Pydantic v2):
date_filter: str = Field(..., pattern=r"^\d{4}-\d{2}-\d{2}$")
```

### BUG-002: Relative Import Errors in FastAPI Services

**Date**: 2025-07-29  
**Service**: report-generator  
**Issue**: `ImportError: attempted relative import beyond top-level package` when testing service startup  
**Root Cause**: Using relative imports (..business.services) in standalone module execution  
**Solution**: Convert to absolute imports using package name (business.services)  
**Files Changed**: `src/interface/app.py`  
**Prevention**: Use absolute imports for all service layers, test imports early  
**Symptoms**: `Expression of type "None" cannot be assigned to parameter` errors  
**Root Cause**: Strict type checking requires explicit Optional typing for None defaults  
**Solution**: Use `Optional[Type]` annotation for all parameters with None defaults  
**Files Changed**: `src/business/exceptions.py`, `src/business/services/*.py`  
**Prevention**: Always use `Optional[Type]` instead of `Type = None` in function signatures  

**Code Fix**:

```python
# WRONG:
def __init__(self, logger: logging.Logger = None):

# CORRECT:
def __init__(self, logger: Optional[logging.Logger] = None):
```

### BUG-003: Virtual Environment Path Issues

**Date**: 2025-07-29  
**Service**: All services  
**Issue**: Service tests and startup failing due to incorrect Python environment  
**Symptoms**: Import errors, missing dependencies when running outside venv  
**Root Cause**: Not activating virtual environment before running commands  
**Solution**: Always activate venv with `source .venv/bin/activate` before service operations  
**Prevention**: Create wrapper scripts that automatically activate venv  

**Command Pattern**:

```bash
# WRONG:
cd services/report-generator && python src/main.py

# CORRECT:
cd /home/jon/repos/charlie-reporting && source .venv/bin/activate && cd services/report-generator && python src/main.py
```

### 🔧 Bug: Relative Import Errors in Service Modules

*Date: 2025-07-29*  
**Issue**: `ImportError: attempted relative import beyond top-level package` when importing FastAPI app  
**Symptoms**: Service fails to start with relative import errors (e.g., `from ..business.services import *`)  
**Root Cause**: Python package structure doesn't support relative imports when running modules directly  
**Solution**: Convert all relative imports to absolute imports in service modules  
**Prevention**: Use absolute imports in all service code, test startup after changes  

**Fixing Pattern**:

```python
# WRONG (relative imports):
from ..business.services import ReportProcessingService
from .schemas import ProcessingResult

# CORRECT (absolute imports):
from business.services import ReportProcessingService  
from interface.schemas import ProcessingResult
```

**Testing Command**:

```bash
cd /home/jon/repos/charlie-reporting && source .venv/bin/activate && cd services/report-generator && python -c "
import sys, os
sys.path.insert(0, os.path.join(os.getcwd(), 'src'))
from interface.app import app
print('✅ Service imports successfully')
"
```

## Lessons Learned & Error Prevention

*Instructions to avoid repeating common mistakes*

### 🚨 Critical Development Rules

1. **Always Check Virtual Environment**
   - NEVER run Python commands without activating `.venv` first
   - Verify with `which python` before executing scripts
   - Include venv activation in all documentation examples

2. **Pydantic Version Compatibility**
   - Check Pydantic version before using validation features
   - Use `pattern=` not `regex=` for Pydantic v2+
   - Test schema validation after any Pydantic upgrades

3. **Type Annotation Consistency**
   - Use `Optional[Type]` for all parameters that can be None
   - Import `Optional` from `typing` module in all files
   - Enable strict type checking in development environment

4. **Service Architecture Compliance**
   - Business layer must NEVER import infrastructure components
   - Interface layer coordinates between business and infrastructure
   - Use dependency injection for all cross-layer communication

5. **Configuration Management**
   - Environment variables must always have sensible defaults
   - Configuration validation should happen at startup
   - Never hardcode paths or connection strings

### 🛠️ Pre-Development Checklist

Before making changes to any service:

- [ ] Virtual environment activated (`source .venv/bin/activate`)
- [ ] Dependencies installed (`pip install -r requirements.txt`)
- [ ] Type checking enabled (mypy/pylance)
- [ ] Architecture compliance verified (no cross-layer violations)
- [ ] Configuration defaults reviewed
- [ ] Health checks functional

### 🔄 Testing Protocol

Before considering implementation complete:

- [ ] Unit tests pass for business logic
- [ ] Integration tests pass for API endpoints
- [ ] Service starts without errors
- [ ] Health check endpoints respond correctly
- [ ] API documentation generates properly (`/docs` endpoint)
- [ ] Metrics collection functional

### 📝 Documentation Requirements

When fixing bugs or implementing features:

- [ ] Update bug log with issue and solution
- [ ] Add lessons learned if applicable
- [ ] Update architecture docs if patterns change
- [ ] Include code examples in solutions
- [ ] Document prevention strategies
